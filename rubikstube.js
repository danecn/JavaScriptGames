// Generated by CoffeeScript 1.9.1
(function() {
  "use strict";
  var Cube, addRanking, aligns, canvas, colors, combo, context, disabled, disappLen, disappTime, draw, drawTrianble, drop, dropDec, dropInc, dropPt, dropables, erased, fallSpeed, fps, gameOver, getRanking, height, initialHeight, isGameOver, level, main, mode, mouseEventHandler, newGame, now, offsetX, offsetY, ontap, point, push, pushSpeed, pushable, random, rankData, rankOrd, ranking, restitute, scale, score, setRanking, slidable, slide, slideSpeed, time, touchEventHandler, touchend, touches, touchmove, touchstart, tube, updateDisapp, updateDrop, updateStable, updateX, updateY, version, width, writeText;

  window.onload = function() {
    return newGame();
  };

  version = "4.0";

  colors = ["#f00", "#0f0", "#00f", "#ff0", "#f0f", "#0ff"];

  fps = 20;

  width = 5;

  height = 10;

  initialHeight = 5;

  slideSpeed = 1 / 2;

  pushSpeed = 1 / 2;

  fallSpeed = 1 / 4;

  dropInc = 30 * fps;

  dropDec = function() {
    return 30 + level();
  };

  disappLen = 4;

  disappTime = 8;

  level = function() {
    return Math.floor(erased / 16) + 1;
  };

  point = function() {
    return combo * level();
  };

  mode = tube = erased = score = combo = dropPt = time = disabled = null;

  newGame = function() {
    var j, k, ref, ref1, x, y;
    mode = "newGame";
    tube = [];
    for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      tube[x] = [];
      for (y = k = 0, ref1 = height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        if (y < height - initialHeight) {
          tube[x][y] = new Cube(false);
        } else {
          tube[x][y] = new Cube(true, {
            dy: initialHeight
          });
        }
      }
    }
    erased = 0;
    score = 0;
    combo = 0;
    dropPt = 0;
    draw();
  };

  main = function() {
    mode = "main";
    updateX();
    updateY();
    updateDrop();
    updateDisapp();
    draw();
    if (isGameOver()) {
      setTimeout(gameOver);
    } else {
      time += 1000 / fps;
      setTimeout(main, time - now());
    }
  };

  gameOver = function() {
    mode = "gameOver";
    draw();
    disabled = true;
    setTimeout((function() {
      disabled = false;
    }), 1000);
  };

  ranking = function() {
    mode = "ranking";
    addRanking();
    draw();
    disabled = true;
    setTimeout((function() {
      disabled = false;
    }), 1000);
  };

  ontap = function(x, y) {
    switch (mode) {
      case "newGame":
        time = now();
        main();
        break;
      case "main":
        if (x === -1 && (0 <= y && y < height) && slidable(y)) {
          slide(y, +1);
        } else if (x === width && (0 <= y && y < height) && slidable(y)) {
          slide(y, -1);
        } else if (y === height && (0 <= x && x < width) && pushable(x)) {
          push(x);
        }
        break;
      case "gameOver":
        if (!disabled) {
          ranking();
        }
        break;
      case "ranking":
        if (!disabled) {
          newGame();
        }
    }
  };

  updateX = function() {
    var j, k, ref, ref1, x, y;
    for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        if (tube[x][y].exists) {
          tube[x][y].dx = restitute(tube[x][y].dx, slideSpeed, slideSpeed);
        }
      }
    }
  };

  updateY = function() {
    var j, k, l, ref, ref1, ref2, x, y;
    for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = height - 2; 0 <= ref1 ? k <= ref1 : k >= ref1; y = 0 <= ref1 ? ++k : --k) {
        if (tube[x][y].exists) {
          if (tube[x][y].dy > 0 && !tube[x][y + 1].exists) {
            tube[x][y + 1] = tube[x][y];
            tube[x][y + 1].dy--;
            tube[x][y] = new Cube(false);
          } else if (!tube[x][y + 1].exists || tube[x][y].dy < tube[x][y + 1].dy) {
            tube[x][y].dy += fallSpeed;
          }
        }
      }
      tube[x][height - 1].dy = restitute(tube[x][height - 1].dy, pushSpeed, fallSpeed);
      for (y = l = ref2 = height - 2; ref2 <= 0 ? l <= 0 : l >= 0; y = ref2 <= 0 ? ++l : --l) {
        if (tube[x][y].exists && tube[x][y + 1].exists && tube[x][y].dy > tube[x][y + 1].dy) {
          tube[x][y].dy = tube[x][y + 1].dy;
        }
      }
    }
  };

  updateDrop = function() {
    var list;
    dropPt -= dropDec();
    while (dropPt < 0) {
      list = dropables();
      if (list.length === 0) {
        return;
      }
      drop(random(list));
      dropPt += dropInc;
    }
  };

  updateStable = function() {
    var j, k, ref, ref1, stable, x, y;
    for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      stable = true;
      for (y = k = ref1 = height - 1; ref1 <= 0 ? k <= 0 : k >= 0; y = ref1 <= 0 ? ++k : --k) {
        stable && (stable = tube[x][y].exists && tube[x][y].dy === 0);
        tube[x][y].stable = stable && tube[x][y].dx === 0;
      }
    }
  };

  aligns = [
    function(x, y, i) {
      return tube[(x + i) % width][y];
    }, function(x, y, i) {
      return tube[x][y + i];
    }, function(x, y, i) {
      return tube[(x + i) % width][y + i];
    }, function(x, y, i) {
      return tube[(x + i) % width][y - i];
    }
  ];

  updateDisapp = function() {
    var a, j, k, l, len, m, n, o, p, ref, ref1, ref2, ref3, results, results1, x, y;
    for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
      for (y = k = 0, ref1 = height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
        if (tube[x][y].exists) {
          if (tube[x][y].disapp === disappTime) {
            tube[x][y] = new Cube(false);
          }
          if (tube[x][y].disapp > 0) {
            tube[x][y].disapp++;
          }
        }
      }
    }
    updateStable();
    for (l = 0, len = aligns.length; l < len; l++) {
      a = aligns[l];
      for (x = m = 0, ref2 = width; 0 <= ref2 ? m < ref2 : m > ref2; x = 0 <= ref2 ? ++m : --m) {
        for (y = n = 0, ref3 = height; 0 <= ref3 ? n < ref3 : n > ref3; y = 0 <= ref3 ? ++n : --n) {
          if (tube[x][y].stable && (function() {
            results = [];
            for (var o = 1; 1 <= disappLen ? o < disappLen : o > disappLen; 1 <= disappLen ? o++ : o--){ results.push(o); }
            return results;
          }).apply(this).every(function(i) {
            return (a(x, y, i) != null) && a(x, y, i).stable && a(x, y, i).color === tube[x][y].color;
          })) {
            (function() {
              results1 = [];
              for (var p = 0; 0 <= disappLen ? p < disappLen : p > disappLen; 0 <= disappLen ? p++ : p--){ results1.push(p); }
              return results1;
            }).apply(this).forEach(function(i) {
              if (a(x, y, i).disapp === 0) {
                a(x, y, i).disapp = 1;
                erased += 1;
                combo += 1;
                return score += point();
              }
            });
          }
        }
      }
    }
  };

  isGameOver = function() {
    return tube.every(function(col) {
      return col.every(function(cube) {
        return cube.stable;
      });
    });
  };

  dropables = function() {
    var j, results;
    return (function() {
      results = [];
      for (var j = 0; 0 <= width ? j < width : j > width; 0 <= width ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).filter(function(x) {
      return !tube[x][0].exists;
    });
  };

  drop = function(x) {
    tube[x][0] = new Cube(true, {
      dy: -1
    });
  };

  slidable = function(y) {
    var j, results;
    return (function() {
      results = [];
      for (var j = 0; 0 <= width ? j < width : j > width; 0 <= width ? j++ : j--){ results.push(j); }
      return results;
    }).apply(this).every(function(x) {
      return tube[x][y].stable && tube[x][y].disapp === 0;
    });
  };

  slide = function(y, dir) {
    var j, k, l, m, ref, ref1, ref2, ref3, temp, x;
    combo = 0;
    switch (dir) {
      case +1:
        temp = tube[width - 1][y];
        for (x = j = ref = width - 1; ref <= 1 ? j <= 1 : j >= 1; x = ref <= 1 ? ++j : --j) {
          tube[x][y] = tube[x - 1][y];
        }
        tube[0][y] = temp;
        for (x = k = 0, ref1 = width; 0 <= ref1 ? k < ref1 : k > ref1; x = 0 <= ref1 ? ++k : --k) {
          tube[x][y].dx = -1;
          tube[x][y].stable = false;
        }
        break;
      case -1:
        temp = tube[0][y];
        for (x = l = 0, ref2 = width - 2; 0 <= ref2 ? l <= ref2 : l >= ref2; x = 0 <= ref2 ? ++l : --l) {
          tube[x][y] = tube[x + 1][y];
        }
        tube[width - 1][y] = temp;
        for (x = m = 0, ref3 = width; 0 <= ref3 ? m < ref3 : m > ref3; x = 0 <= ref3 ? ++m : --m) {
          tube[x][y].dx = +1;
          tube[x][y].stable = false;
        }
    }
  };

  pushable = function(x) {
    var j, ref, y;
    for (y = j = ref = height - 1; ref <= 0 ? j <= 0 : j >= 0; y = ref <= 0 ? ++j : --j) {
      if (!tube[x][y].exists) {
        return true;
      }
      if (tube[x][y].dx !== 0 || tube[x][y].dy > 0 || tube[x][y].disapp > 0) {
        return false;
      }
    }
    return false;
  };

  push = function(x) {
    var temp1, temp2, y;
    combo = 0;
    temp1 = null;
    temp2 = new Cube(true);
    y = height - 1;
    while (temp2.exists) {
      temp1 = temp2;
      temp2 = tube[x][y];
      tube[x][y] = temp1;
      tube[x][y].dy++;
      y--;
    }
  };

  restitute = function(x, a, b) {
    if (x > a) {
      return x - a;
    } else if (x < -b) {
      return x + b;
    } else {
      return 0;
    }
  };

  random = function(array) {
    return array[Math.floor(Math.random() * array.length)];
  };

  now = function() {
    return new Date().getTime();
  };

  rankData = rankOrd = null;

  addRanking = function() {
    var i, j, ref, ref1;
    getRanking();
    rankOrd = 1;
    while (rankOrd <= height && (rankData[rankOrd] != null) && rankData[rankOrd] > score) {
      rankData++;
    }
    if (rankOrd <= height) {
      for (i = j = ref = height, ref1 = rankOrd; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
        rankData[i] = rankData[i - 1];
      }
      rankData[rankOrd] = score;
    }
    return setRanking();
  };

  getRanking = function() {
    if (localStorage.getItem("rubikstube.version") === version) {
      rankData = JSON.parse(localStorage.getItem("rubikstube.ranking"));
    } else {
      rankData = [];
    }
  };

  setRanking = function() {
    localStorage.setItem("rubikstube.version", version);
    localStorage.setItem("rubikstube.ranking", JSON.stringify(rankData));
  };

  touches = {};

  touchstart = function(id, x, y) {
    x = Math.floor((x - offsetX) / scale);
    y = Math.floor((y - offsetY) / scale);
    touches[id] = {
      x0: x,
      y0: y,
      x: x,
      y: y
    };
    ontap(x, y);
  };

  touchmove = function(id, x, y) {
    var ref, ref1, ref2, t;
    if (touches[id] != null) {
      t = touches[id];
      x = Math.floor((x - offsetX) / scale);
      y = Math.floor((y - offsetY) / scale);
      t.x = x;
      t.y = y;
      if (t.x > t.x0 && t.y === t.y0 && (0 <= (ref = t.y) && ref < height) && slidable(t.y)) {
        slide(t.y, +1);
        t.x0++;
      } else if (t.x < t.x0 && t.y === t.y0 && (0 <= (ref1 = t.y) && ref1 < height) && slidable(t.y)) {
        slide(t.y, -1);
        t.x0--;
      } else if (t.y < t.y0 && t.x === t.x0 && (0 <= (ref2 = t.x) && ref2 < width) && pushable(t.x)) {
        push(t.x);
        t.y0--;
      }
    }
  };

  touchend = function(id) {
    if (touches[id] != null) {
      delete touches[id];
    }
  };

  mouseEventHandler = function(event) {
    switch (event.type) {
      case "mousedown":
        touchstart("mouse", event.clientX, event.clientY);
        break;
      case "mousemove":
        touchmove("mouse", event.clientX, event.clientY);
        break;
      case "mouseup":
        touchend("mouse");
    }
  };

  addEventListener("mousedown", mouseEventHandler);

  addEventListener("mousemove", mouseEventHandler);

  addEventListener("mouseup", mouseEventHandler);

  touchEventHandler = function(event) {
    var j, len, ref, t;
    event.preventDefault();
    ref = event.changedTouches;
    for (j = 0, len = ref.length; j < len; j++) {
      t = ref[j];
      switch (event.type) {
        case "touchstart":
          touchstart(t.identifier, t.clientX, t.clientY);
          break;
        case "touchmove":
          touchmove(t.identifier, t.clientX, t.clientY);
          break;
        case "touchend":
        case "touchcancel":
          touchend(t.identifier);
      }
    }
  };

  addEventListener("touchstart", touchEventHandler);

  addEventListener("touchmove", touchEventHandler);

  addEventListener("touchend", touchEventHandler);

  addEventListener("touchcancel", touchEventHandler);

  canvas = document.getElementById("canvas");

  context = canvas.getContext("2d");

  scale = offsetX = offsetY = null;

  draw = function() {
    var color, i, j, k, l, m, n, ref, ref1, ref2, ref3, ref4, x, y;
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    scale = Math.floor(Math.min(canvas.width / (width + 2), canvas.height / (height + 2)));
    offsetX = Math.floor((canvas.width - width * scale) / 2);
    offsetY = Math.floor((canvas.height - height * scale) / 2);
    context.setTransform(scale, 0, 0, scale, offsetX, offsetY);
    switch (mode) {
      case "newGame":
      case "main":
      case "gameOver":
        context.save();
        context.beginPath();
        context.rect(0, 0, width, height);
        context.clip();
        context.fillStyle = "#000";
        context.fillRect(0, 0, width, height);
        for (x = j = 0, ref = width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
          for (y = k = 0, ref1 = height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
            if (tube[x][y].exists) {
              tube[x][y].draw(x, y);
            }
          }
        }
        context.restore();
        writeText("Lv." + String(level()), 0.7, -1, 0, "left", "bottom");
        writeText(String(score) + "pt", 0.7, width + 1, 0, "right", "bottom");
        switch (mode) {
          case "newGame":
            context.fillStyle = "#fff";
            context.fillRect(0, height / 2 - 1 / 2, width, 1);
            writeText("Tap to Start", 0.7, width / 2, height / 2, "center", "middle");
            break;
          case "main":
            for (y = l = 0, ref2 = height; 0 <= ref2 ? l < ref2 : l > ref2; y = 0 <= ref2 ? ++l : --l) {
              if (slidable(y)) {
                drawTrianble(-1, 0, 0, 1, 0, y);
                drawTrianble(1, 0, 0, 1, width, y);
              }
            }
            for (x = m = 0, ref3 = width; 0 <= ref3 ? m < ref3 : m > ref3; x = 0 <= ref3 ? ++m : --m) {
              if (pushable(x)) {
                drawTrianble(0, 1, 1, 0, x, height);
              }
            }
            break;
          case "gameOver":
            context.fillStyle = "#fff";
            context.fillRect(0, height / 2 - 1 / 2, width, 1);
            writeText("Game Over", 0.7, width / 2, height / 2, "center", "middle");
        }
        break;
      case "ranking":
        writeText("Ranking", 0.7, width / 2, 0, "center", "bottom");
        for (i = n = 1, ref4 = height; 1 <= ref4 ? n <= ref4 : n >= ref4; i = 1 <= ref4 ? ++n : --n) {
          if (rankData[i] != null) {
            color = i === rankOrd ? "#f00" : "#000";
            writeText(String(i), 0.7, -1, i, "left", "bottom", color);
            writeText(String(rankData[i]) + "pt", 0.7, width + 1, i, "right", "bottom", color);
          }
        }
    }
    writeText("v" + version, 0.35, width + 1, height + 1, "right", "bottom");
  };

  addEventListener("resize", draw);

  writeText = function(text, size, x, y, align, base, color) {
    if (color == null) {
      color = "#000";
    }
    context.save();
    context.transform(size / 10, 0, 0, size / 10, x, y);
    context.fillStyle = color;
    context.font = "10px Courier, monospace";
    context.textAlign = align;
    context.textBaseline = base;
    context.fillText(text, 0, 0);
    context.restore();
  };

  drawTrianble = function(a, b, c, d, x, y) {
    context.save();
    context.transform(a, b, c, d, x, y);
    context.beginPath();
    context.moveTo(0.2, 0.5);
    context.lineTo(0.8, 0.3);
    context.lineTo(0.8, 0.7);
    context.closePath();
    context.fillStyle = "#000";
    context.fill();
    return context.restore();
  };

  Cube = (function() {
    function Cube(exists, option) {
      var key, value;
      this.exists = exists;
      if (this.exists) {
        this.color = random(colors);
        this.dx = 0;
        this.dy = 0;
        this.disapp = 0;
        if (option != null) {
          for (key in option) {
            value = option[key];
            this[key] = value;
          }
        }
      }
      this.stable = false;
    }

    Cube.prototype.draw = function(x, y) {
      var i, j;
      context.fillStyle = this.disapp % 2 === 0 ? this.color : "#fff";
      for (i = j = -1; j <= 1; i = ++j) {
        context.save();
        context.translate(i * width + x + this.dx, y + this.dy);
        context.beginPath();
        context.arc(0.6, 0.6, 0.4, 0 / 2 * Math.PI, 1 / 2 * Math.PI);
        context.arc(0.4, 0.6, 0.4, 1 / 2 * Math.PI, 2 / 2 * Math.PI);
        context.arc(0.4, 0.4, 0.4, 2 / 2 * Math.PI, 3 / 2 * Math.PI);
        context.arc(0.6, 0.4, 0.4, 3 / 2 * Math.PI, 4 / 2 * Math.PI);
        context.closePath();
        context.fill();
        context.restore();
      }
    };

    return Cube;

  })();

}).call(this);
